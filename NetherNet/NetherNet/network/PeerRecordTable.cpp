
#include "PeerRecordTable.hpp"
#include "../HNetherNet.hpp"

namespace NetherNet {
	void PeerRecordTable::RemoveExpiredRecords(NetherNet::Utils::ThreadSafe<std::map<NetworkID, PeerRecordTable::PeerRecord>>::View const& exclusiveTable) {
		auto& table = exclusiveTable.get();
		for (auto& i : table) {
			auto current_time = std::chrono::high_resolution_clock::now();

			if (std::chrono::duration_cast<std::chrono::seconds>(current_time - i.second.mLastActiveTime)
				<= std::chrono::seconds(60)) {
				//TODO: dunno if this part is generated by compiler
			}
			else {
				auto cur_time = std::chrono::high_resolution_clock::now();
				auto active_delta = std::chrono::duration_cast<std::chrono::seconds>(
					current_time - i.second.mLastActiveTime
				);

				auto addr_str = i.second.mRemoteAddress.ToString();
				NetherNet::NetherNetTransport_LogMessage(
					LogSeverity::Information,
					"[LAN] Removing [%llu] at '%s' from databse, has been inactive for %lld seconds",
					i.second.mRemoteId,
					addr_str.data(),
					active_delta
				);

				//TODO: dunno if this part is generated by compiler
				//Here...
				//

				exclusiveTable.get().erase(i.first);
			}
		}
	}

	bool PeerRecordTable::Find(NetworkID id, rtc::SocketAddress* pOutAddr) {
		RemoveExpiredRecords(mExclusiveTable.get());

		auto record = mPeerRecordTable.find(id);

		//TODO: probably also std::less checking, probably more complex then just simply checking if it contains.
		if (record != mPeerRecordTable.end()) {
			*pOutAddr = record->second.mRemoteAddress;
			return true;
		}

		return false;
	}

	bool PeerRecordTable::Contains(NetworkID id) {
		RemoveExpiredRecords(mExclusiveTable.get());

		//TODO: probably also std::less checking, probably more complex then just simply checking if it contains.
		return mPeerRecordTable.contains(id);
	}

	bool PeerRecordTable::AddOrUpdate(NetworkID networkID, rtc::SocketAddress const& address) {
		RemoveExpiredRecords(mExclusiveTable.get());

		bool insert_new = false;

		auto record = mPeerRecordTable.find(networkID);

		//TODO: probably also std::less checking, dunno if it is generated by compiler.
		if (record == mPeerRecordTable.end()) {
			auto str_addr = address.ToString();
			NetherNet::NetherNetTransport_LogMessage(LogSeverity::Information, "[LAN] Adding [%llu] at '%s' to database", networkID, str_addr.data());

			//TODO: idk...
			if (!mPeerRecordTable.contains(networkID)) {
				PeerRecord new_peer_rec;
				new_peer_rec.mLastActiveTime = NetherNet::Utils::GetTimeNow();
				new_peer_rec.mRemoteAddress = address;
				new_peer_rec.mRemoteId = networkID;

				mPeerRecordTable.insert({ networkID, new_peer_rec });
			}
			insert_new = true;
		}
		else {
			if(address == record->second.mRemoteAddress)
				NetherNet::NetherNetTransport_LogMessage(LogSeverity::Information, "[LAN] Updating database for [%llu]", networkID);
			else {
				auto str_new_addr = address.ToString();
				auto str_old_addr = record->second.mRemoteAddress.ToString();

				NetherNet::NetherNetTransport_LogMessage(
					LogSeverity::Information,
					"[LAN] Updating database for [%llu] from '%s' to '%s'",
					networkID,
					str_old_addr,
					str_new_addr);
			}

			record->second.mRemoteAddress = address;
			record->second.mLastActiveTime = std::chrono::high_resolution_clock::now();
			insert_new = false;
		}

		return insert_new;
	}
}